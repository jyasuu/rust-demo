use std::{env, fs, path::Path};

fn main() {
    // Tell Cargo to re-run if these files change
    println!("cargo:rerun-if-changed=c_src/example.c");
    
    // Compile the C code
    cc::Build::new()
        .file("c_src/example.c")
        .compile("example");  // Produces libexample.a

        
    // Re-run if config changes
    println!("cargo:rerun-if-changed=config/my_config.json");

    // Read config file
    let config_path = "config/my_config.json";
    let config_data = fs::read_to_string(config_path)
        .expect("Failed to read config file");

    // Parse JSON
    let config: serde_json::Value = serde_json::from_str(&config_data)
        .expect("Invalid JSON config");

    // Generate Rust code
    let mut output = String::from("// AUTO-GENERATED BY build.rs\n\n");
    
    if let Some(endpoints) = config["endpoints"].as_array() {
        for endpoint in endpoints {
            let name = endpoint["name"].as_str().expect("Missing endpoint name");
            let path = endpoint["path"].as_str().expect("Missing endpoint path");
            
            output.push_str(&format!(
                r#"pub fn {}() -> String {{
                    "Endpoint: {} at {}".to_string()
                }}
                "#,
                name, name, path
            ));
        }
    }

    // Write to OUT_DIR
    let out_dir = env::var("OUT_DIR").expect("Missing OUT_DIR");
    let dest_path = Path::new(&out_dir).join("generated_config.rs");
    fs::write(&dest_path, output).expect("Failed to write generated code");
}